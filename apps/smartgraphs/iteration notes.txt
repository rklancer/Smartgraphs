6/16/10:

Refactoring RaphaelViews to work better and to support prediction graphs/higher sampling rates, etc.

Issues:

resizability
dealing with--possibly animating--scale changes
eliding path/point difference (assume points can be their own views, maybe; but lines can't)
avoiding memory leaks or slowness
hooking into SC event system
allowing annotations to be added (and animated) on top. Does SC.Animatable matter here?

do we really need to make scatter plot views extend collection view? Is it worth it?

I think so. Composability: you can implement different types of itemView (one for scatter plots, one for lollipop style plots) Options: you get isSelected support for example as well as recycling of views? Plus you don't have to handle events, I guess.

(How does this play with touch events? I dunno.)

Considerations:




6/10/10:


things to fixup:

  * general scheme of response applet loading .. the data path, at least, shouldn't be in a view; and deal with timing issues!
  * some hooks for/research about applet loading forensics
  * loading indicator for applet controls and delayed or background loading (make sure applet loading doesn't affect page progression)
  * are there issues with pluggin in/unplugging sensor?
  * IE developer tools
  * what about JNA access to host usb libraries?
  * what about static serving of applet jar -- is it possible?
  * update to latest master and confirm it fixes text area click to focus problem.
  * investigate updating to quilmes

  * investigate timing and binding issues within the sproutcore app overall
  * look at the response template model and view ... can using a "student response" model avoid 'manual' clearing and updating?

  * create tests generally
  * create tests that fail in IE?

  * rationalizing how raphael views work 
      (get rid of requirement that raphaelview be direct parent. create a base class that knows when to render? get rid of layer z index hack)

  * decompose the axes model into 2-axes (create yAxisController and xAxisController?)
  * make data series controller and axis controller not singletons, so multiple graphs can be displayed
  * rationalize how plotting works -- axis should handle coordinate transforms!

  * make view for individual static annotations,
  * investigate the 'command' idea; how does this fit in with logbook data model?
  
  * investigate fixes needed for touch to work with raphael views
  * lots more, I'm sure...





----

open question for 6/2: 

how to specify data series and axes per guide page? (actually, that should be easy!)

how to specify applet on/off?


6/1/10:

* let responsetemplates link to a list of ResponseField objects?
* create an 'open response' responsetemplate and let the view use it

* about 'response verifier delegates':

  * in general, the idea of objects that can be configured and that observe the system state are useful.
  * (they convert the system state to a bunch of booleans, basically)
  * some of these will observe the state of the data input from a sensor -- for example is there enough data yet?
  * verifier delegates are *one such kind* that are for the specific case of user-initiated checking
  * dialogturns will eventually have configurable feedback fields that can give 'real time' feedback e.g., 'you haven't entered enough data yet'
  * stateObserverDelegates or whatever we want to rename responseVerifierDelegates could update those fields
  
* so we have the idea that dialogturns can gate progress in a configurable way based on feedback from the state observer
* perhaps a progressGatingController will come into play? that can be configured with a suitable delegate configured via a suitable model object (analogously to responseVerifiers)
* note we sort of have something analogous now in that you can't click check response button until !responseIsIncomplete
* progress is gated now in these ways:
    * you go to the next dialog turn after you click checkResponse (only if response is correct or incorrect, not malformed or incomplete in which case you should get feedback)
    * you can't even click checkresponse until response is 'not incomplete'
* later we can have: 
    * you go to the next turn after you click OK
    * but you can't click OK until state is 'ok to progress'


*** THE CONCEPTS WE'LL USE:

there's a 'progress' button
the button can have a configurable title? ('check response', 'ok'). (As per Kofi let the authoring system enforce name of these things.)
there's a system observer which distill system state into a configurable set of values, and can be configured in extensible way via:
  1. naming the delegate object
  2. config string
  
there's a *separate* response checker that takes the distilled system state and gives yes/no on progress to next step

the system observer object can be used to turn buttons on/off, give 'real time' feedback (ie without waiting for student to click)

the dialog turn has to be configured to 1) use a particular system observer 2) bind certain feedback fields (which *are* predefined) to certain keys on the system observer (which are specified as strings)

I.E. we're blowing up 'response verifier' into two things


*** FOR NOW this doesn't matter.

we just need to implement OK button, right?



*** how would this work?

nextTurnButtonTitle: 'Check My Response'
responseVerifier: response-1    // checks with systemStateDistiller; if null, goto 'nominal response'
systemStateDistiller:'responseTemplate, 'graphSelection'  (-Distiller)

(then there'd be a template language and/or fields on the DialogTurn model that bind the instant-feedback to distiller objects' various properties)

checkResponse -> checkState

responseIsCorrect/responseIsIncorrect -> stateIsOK
responseIsMalformed+responseIsIncomplete+whatever else means that 'stateOK' is not valid -> stateIsValid
checkState was called -> stateWasChecked



*** what do we need now?

nextTurnButtonTitle: "Submit My Answer"
responseVerifier: null means progress button always enabled. *** Actually, we could create a null checker before separating distillers from gatingsupervisors


sigh, all these java-y class names



okay. we're good to go for open response




  


5/30/10:

(renamed CorrectResponse to ResponseVerifer)

OK, now we have a division of responsibility when checking answers.

If the dialog will need to present input area(s) (possibly intermixed with text), the ResponseTemplate will contain the
necessary information (in its templateString)

There should also be an associated ResponseVerifier which has responsibility for checking the answer.

OKAY:

  * responseTemplate should have an array that contains the responses. These might be processed, depending.
  * responseVerifier should have a 'type' parameter that specifies the type of answer to be checked.
   
  based on the responseVerifier's 'type' parameter, the responseVerifier will check a different delegate
  it can pass its 'value' parameter to the delegate, which is responsible for figuring out what to do with it.

  verifier-delegates/
    ReponseTemplateVerifierDelegate
    GraphSelectionVerifierDelegate
 



5/27/10:

view layer changes:

 mainPage.promptView becomes 'dialogView'
 
 



next step: controllers and actions

GuidePageSequenceController

GuidePageController

DialogController

DialogTurnController




5/26/10

What to actually implement to get text dialog working

GuidePageSequence
  pages
  
GuidePage
  activity
  text
  dialog
  
Dialog
  // eventually we'll interpose a dialogstepsequence so that a dialog can have su
  steps
  
DialogStep
  index
  dialog
  beforeText
  responseTemplate: toOne(ResponseTemplate)
  staticAnnotations: (i.e., static, not replayable annotations)
  afterText

ResponseTemplate
  type: 
  formatString:
  correctResponse
  
CorrectResponse
  // a DialogStep without a correctResponse is basically an 'open response'
  responseTemplate: 
  value

StaticAnnotationList:
  annotations: toMany(StaticAnnotation)

StaticAnnotation
  list:       toOne(StaticAnnotation)
  type        (a string)
  args        (?)





5/25/10

new objects:

GuidePageSequence    (an 'activity' or a sequence of 'pages', without all the connotations of 'activity' -- e.g,  it could be a wizard)
ActivityStep          (a 'page' in the 'activity', with the expectation that steps can be followed linearly -- if a student needs help with a step, he gets it in the step itself)
Dialog                (a description of the dialog between system and user that takes place during a single ActivityStep)
DialogStep            (a step in that dialog)

points to remember about Dialogs:

1. the dialog is linear. The expectation is you continue until student 'gets it right'
2. at any point, you might want to, say, have student record their notes about what they're doing. That's a dialogStep?
3. there's an optional 'finish' step after the student gets it right, which must be completed before they can move on.
4. but we'll enforce that there aren't any more 'check responses' at that point.


A dialog step consists of 

text (displayed before or after the answer form)
a graphical action (specified by a 'name'))
an answer form -or- a reflection form (which I guess can take a similar form but doesn't record the answer to the same place and doesn't have a 'check answer' button)
[eventually, you might want to include a button that the user can click on to perform some action like open a tool]
(simplify, simplify! no 'text before' and 'text after' stuff. just text...)


the answer form is a template with (with a list of actions to take after an answer)
the graphical action consists of a list of actions by name
the buttons contain "ok" if no answer form; "show me again" if action; "check my answer" and "i don't know" if there's an answer form
there can also be a list of actions defined in a step

alternatively, a step can be a link to a 'subdialog'

instead of having a 'finally clause', allow a dialog to contain multiple DialogStepSequences.

Answering a question correctly (see AnswerForm) in a DialogStepSequence skips to the next sequence, if any.


I think we have what we need to model this.


GuidePageSequence
  steps: toMany(GuidePage)
  

GuidePage
  guidedUserActivity: toOne(GuidePageSequence)
  text:
  configuration:
  lowerRight: ?
  upperRight: ?
  dialog: toOne(Dialog)


Dialog
  index: Number
  GuidePage: toOne(GuidePage)
  sequences: toMany(DialogStepSequence)
  dialog: toOne(Dialog)
  steps: toMany(DialogSteps)
  

DialogTurnSequence
  dialog: toOne(Dialog)
  index: 
  turns: toMany(DialogTurns)


DialogStep
  index: Number
  sequence: toOne(DialogStepSequence)
  
  beforeText: String
  responseForm: toOne(ResponseForm)
  responseVerifier: toOne(ResponseVerifer)
  graphicalActions: toOne(ActionSequence)

  afterText: String
  subDialog: toOne(Dialog)

  actions: toOne(ActionSequence)
  

ResponseForm:
  type: String  (one of two constants)
  correctResponse:
  eventually, other fields that allow 
    
    
ActionSequence:
  actions: toMany(Action)
  

Action:
  index: Number
  sequence: toOne(ActionSequence)



EARLIER THOUGHTS BELOW:


each DialogStep can 'be' a:

posed question              response buttons: checzk answer, OK (if no answer is expected), I don't know
rephrased question          response buttons: check answer, OK (if no answer is expected), I don't know
subquestion                 response buttons: check answer, OK (if no answer is expected), I don't know
graphical hint              response buttons: check answer, OK (if no answer is expected), show me again
textual hint                response buttons: check answer, OK (if no answer is expected)
reflection opportunity      response buttons: OK
textual response            response buttons: OK (or none if it's the last?)
graphical response          response buttons: OK, show me again

* possibly separate the prompting from the setting of a new response expectation
* the funny bit is the idea of a 'prompt'. we want it to repeat, possibly being overridden. 
**  Actually, we need an 'answer form' independent of the 'prompt'
* each step can have associated with it some actions

trying again...
each step can have

text (the 'prompt' goes here, but this can be a hint or whatever)
an 'answer form' (the idea being these repeat until a new one is introduced)
graphic response
(associated actions)
post-incorrect-response text
post-correct-response text





Dialog:

  firstStep                   (first dialogStep to pose)
  afterCompletionStep:        (follow these steps after success)

DialogStep:

(actions:
  set a new response expectation
  do some named actions that annotate the graph
  do some named actions that display a transient annotation
  set a new reflective response question
  switch to a sub-question...)


  repeatableActions           ('graphical scaffolding')
  
  hasCheckResponseButton
  hasShowAgainButton          (to replay actions ... although, which actions?)
  hasOkButton                 (for 'think about it' or 'write what you think will happen' type dialog steps)

  newResponseExpectation      (set this to a new ResponseExpectation to ask a new question)
  text
  actions                     (a set of actions performed by this step)
  afterCorrectResponseText
  afterIncorrectResponseText
  
  subDialog                   (a dialog branch -- possibly including a new response expectation -- to be followed to completion between this step and the next) 
  nextStep
  

reflectionDialogStep
graphicalDialogStep
textDialogStep
checkAnswerDialogStep


textReponseStep
graphicalResponseStep
learnerInputStep
requestLearnerResponseStep




askForResponse

  OK (if reflective input)
  Watch Again:
  



  
issues:
  checking that there's any response at all
  saving a reflective response
  templating for text output (how to say "put a dropdown here between the words 'ran for' and 'minutes'")
  templating for actions on logbook (e.g., how to say 'student's answer should represent length param of length annotation')
  
  
  
5/17/10


make use of this pattern:



// find contact record.
var contactRecord = MyApp.store.find(MyApp.Contact, 4);
// find events assigned to that contact.
var localEventQuery = SC.Query.local(MyApp.Event, {
   conditions: 'assignedTo = {contact}',
   contact: contactRecord
});

IOW

seq = Smartgraphs.store.find(Smartgraphs.QuestionSequence, 'sequence-1');
query = SC.Query.local(Smartgraphs.Question, { conditions: 'sequence = {sequence}', sequence: seq, orderBy: 'index ASC' })
qs = Smartgraphs.store.find(query)


make questionsequenceview an arraycontroller whose content is that query result
make it single selection, no empty selection

bind questionController to selection

to add:

* segmented view (bind to content)
* next/back buttons (need isFirst, isLast, next(), back() on questionSequenceController)

segmentedview has 'itemvaluekey' and a 'value' properties.


can you bind selection of questionController to that value, or do we have to observe the 'value' and set selection accordingly?




to do:

* adjust the question model with short name
* create a simple activity model (questionSequenceController)
* create a query
* make the questionsequenceview an arraycontroller with the appropriate flags set
* endow questionsequenceview with an 'questionSequence' property that points to a questionsequence model object and sets the content property accordingly
* create segmentedview with appropriate
* create next/back buttons and bind accordinglyx`




5/12/10

let's get back to simple.
keep the tabs the same.
set the first tab view to be a 'new' question view.


question MODEL

  responseType
  prompt
  correctResponse
  correctResponseFeedback
  incorrectResponseFeedback
  
  
question CONTROLLER

  checkAnswer()
  feedback
  shouldAcceptTextResponse
  textResponse
  shouldAcceptGraphicalResponse
  graphicalResponse
  response
  
  
question VIEW

  display prompt
  display response if non-null
  display text area if shouldAcceptTextResponse is YES
  bind 'check answer' button to
  

main.js

  should fetch the first question fixture
  should set up the question controller

main_page.js

  the 'introView' should be a 
  

adjust the fixture 



*** see tomdale on pages and containerviews:

  http://groups.google.com/group/sproutcore/msg/9f59c491b9c27464






you presumably want multiple questionview instances, each bound to a question controller
there should be a higher level object that sets up the question controllers as needed

naah.

* set up your files in your main.js like this:

  (the idea is that this logic could be implemented in an app state/root controller)
  
  create 3 question controllers (which should not have to concern themselves with views!)  
  create 3 off-screen panes bound to those controllers
  each pane contains a questionview
  
  set up a question flow controller
  
   isFirst property (views can observe to disable back button)
   isLast property (views can use to enable forward button)
   items is an array of question controllers
   nowShowing is the current question controller
   endow controller with next(), prev() methods to move nowShowing
   itemEnabledKey - pass through to tab controller
   
   
   eventually the tab controller could 'build' the activity incrementally
   

question controllers:


----

5/5/10:


"allow the user to click a point on the graph to answer the question"

okay, what's the flow we're imagining will eventually happen


a wizard poses a question
  the datapoint relays a selection event to the dataseries it's in
  
  the dataseries relays the event to the slide/slidebuilder
  
  the slidebuilder looks at its policy somehow and knows that the correct event is to delegate to the annotationbuilder
  
  the annotationbuilder sends an addannotation event to the slidebuilder (to notate where the annotation is proposed to happen)
  
  when the 'check answer' button is clicked, the wizard inspects that annotationbuilder's datapoint property
  

decompose this into the models needed for this story:


there should be a controller for a wizard-like component, with a state machine and underlying model...

there should be a



try implementing in this iteration:

a new series data model and corresponding views
a slidebuilder (that accepts setAxes, addSeries and addAnnotation)

a relay between the mousedown on the datapoint model,

 * the datapointview gets a click event
 * its controller notifies the dataseriescontroller
 * the arraycontroller for dataseries sets isselected on the datapoint (triggering re-render)
 
 * however, after this, TURN SELECTION OFF in the dataseriesview control (as we're going to be annotating, not selecting)
 (in general, model the listitemview/listview contract if possible?)
 

 * now, the wizard should be notified directly of the selection event (instead of going through an annotation builder .. yet)

 * wizard should check the value of the selected point and act accordingly
 
 * then, add an annotation to the *slide* object (and redisplay)
 
 
what's needed?

* ignore changes having to do with rewriting wizard


DataPointView
DataPointController
DataSeriesView (at least a new version)
DataSeriesController (at least a new version)
AxisView
AxisController

SlideBuilderView
SlideBuilderController
WizardController


models

Axis
Slide
SimpleAnnotation (no or trivial controller)

Wizard (this could be renamed eventually)


steps?


* refactor DataSeriesView to be a CollectionView with DataSeriesView as the exampleView
* make a 'lab book slide' model & controller
* make a 'simple data point annotation' model
* put the first question in a 'wizard' object
* make it so the wizard causes a 'lab book slide' to be created from the data series
* make the 'lab book slide builder' cause annotations to be displayed
* make it so the wizard checks its answer by getting events relayed from datapoint-dataseries-slide chain, and reflects the answer by simply adding a 'simple annotation' object


---

notes on refactoring dataseriesview

  * rename to dataseriesview from seriesview
  * use the collectionviewdelegate to make decisions regarding selection etc (note the 'annotationbuilder' scenario above implies that selection could be used to indicate which datapoint to annotate, rather than merely to 'select')
  
  * 'collectionview handles event input for the entire collection' (from docs for SC.CollectionView)
  
  * note 'action' and 'actOnSelect' properties of CollectionView
  * note on SC.CollectionView's contentValueKey property: "If you are writing your own custom item view for a collection, you can get this behavior automatically by including the SC.Control mixin on your view. You can also ignore this property if you like. The collection view itself does not use this property to impact rendering."
  * "In general you do not want your child views to actually respond to mouse and keyboard events themselves. It is better to let the collection view do that."
  
  * see the notes on exampleView to implement 
  * nowShowing: "The set of indexes that are currently tracked by the collection view"
  ****  contentIndexForLayerId()!
  * contentIndexesInRect() "Override to return an IndexSet with the indexes that are at least partially visible in the passed rectangle"
  
  * contentPropertyDidChange(): OH! "This is only called if you have set observesContentProperties to YES." (tell Avi`)
  
  * itemViewForContentObject()
  
  
  
  so; the plan?
  
  * how much layout does collectionview really do?
  * and how do we handle context building for raphael?
  
  - moved raphaeljs to frameworks/raphael
  
  what might it look like?
  
  should we make the analogy
  
  layer::svg element
  render : overwrites the layer
  
  contextbuilders keep track of innerhtml
  should contextbuilder overwrite layer?
  
  is there an analogy? 
  
  

okay

- why does overriding createLayer() still result in a div being created? how can this be overridden?
- how does listItemView work?



NOTE

Every dom node created with raphael has a 'raphael' property pointing to the raphael object that represents it
every raphael element has a 'paper' property pointing to the 'main' raphael object
the main raphael object has a 'canvas' (instead of 'node') property pointing to the parent dom element(svg/vml node) containing the paper.

Phew.






 

 

sc-gen data-source Smartgraphs.RailsDataSource
 
 