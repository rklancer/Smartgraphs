questions

1. are we including external resources in the 'right' way?
2. what are the contracts regarding css styles?
3. should we set dataSeriesController.content in a different way? Why is it different than the way we set Axes.content?
4. how does resizing work?
5. do we really have to bind explicitly all the properties of Axes to AxesView? To RaphaelView?
6. is the axes controller really the right place to put padding info?
7. is layout guaranteed to updated when a view changes?
8. If we bind layout to an object with a heightBinding, does that work?
9. why not have borderStyle in css?
10. are stacked views supposed to 'stretch'?
11. can we assume all sc guids will be of a particular form?
12. what are all the lifecycle and rerender events on views?
13. what is the deal with 'context' objects? Are these "delayed builders"? Why is it that the layer doesn't seem to necessarily exist when render is called?

14. is it necessary to generate a layer? what if my view doesn't need one?

15. what happens if the mouse leaves the view entirely? Do I get a mouseout type event?
16. what's the deal with key panes, responders, statecharts? (Note etgryphon's irc comment that statecharts replace responders but have the same api)
17. do I really need an 'htmlview'?

--

investigate:

* dataseriescontroller.content = dataseries.points? 

(yes, this is the right design; alternative is to bind content to a query that returns an array of records, which is basically the same idea as using the 'points' property; as per my investigation below, that works okay)

* HOW TO ADD to both sides of a one-to-many relationship? 

(see my comment on wiki!)

* binding to all properties of axesview:

after looking at SC.View, I think the thing to do is bind axesController to axes property on axesView, then have displayproperties be 'axes.xMin' etc

* what is the magic in a listitemview (can we make datapointview like listitemview)?

 any collectionview will render the members of its content array using an object of the class specified by exampleView property
 
 exampleViews should honor content, isSelectable, isEnabled properties; there are a few others that it can observe)
 (see http://frozencanuck.wordpress.com/2010/02/01/summing-up-the-how-to-create-a-simple-custom-list-item-view-tutorial/ especially the first tutorial)
 

* view lifecycle, rendering, resizing, relayout

  createLayer()
    "Creates the layer by creating a renderContext and invoking the view's render() method."
    Apparently you can override this if you want, but how to deal with calling prepareContext, I'm not sure.
  
  render()
   you (can) override this to write to the context. If it's not firstTime, you can also modify the layer directly
   (consensus seems to be that for most views you should rerender to a context
   
   IF YOU OVERRIDE RENDER AND HAVE CHILDVIEWS YOU SHOULD CALL renderChildViews() in your render() method
   
   
  prepareContext()
    "Invoked by createLayer() and updateLayer() to actually render a context."
    
    NOTE: it appears that contexts are updatable, in the following sense (I'm not 100% sure): When updateLayer()
    calls the SC.RenderContext constructor, it passes its 'layer' property, which is the DOM node of the layer.
    (remember the layer isn't even necessarily appended to the document yet, e.g., if insertBefore() or append() ?  
    haven't been called.)
    
    If any builder methods are called on the context, the html generated by those overwrites the innerHTML of the 
    layer DOM node. So the whole layer is built from scratch, but the dom node is reused.
    
    On the other hand, when createLayer() is called, as long as there is in fact no 'layer' property yet, then it
    passes a tag name to the RenderContext constructor, and it stashes the DOM node (retrieved by calling
    context.element()) in its 'layer' property for later use by updateLayer(), etc.
    
  
  updateLayer()
    creates a new context and calls render again.
    
    what it does: gets context from 'layer' property (i.e., DOM node of layer). calls 'render()' with the context
    and with firstTime = NO. Then calls context.update() to actually rewrite the HTML of the layer.
    Calls didAppendLayerToDocument() as needed, didUpdateLayer(), etc.
    
    Interestingly, depending on whether the 'updateMode' property of the RenderContext is SC.MODE_REPLACE or 
    SC.MODE_APPEND, it either creates a new node and appends it, or just overwrites the innerHTML of the old node.
    
    (Remember that the SC viewpoint is that it's better to rerender than do DOM manipulation! so if layer needs update,
    often you'll use the context's builder methods again, rather than using CoreQuery to do the manipulation)
    
    "You will not usually call or override this method directly. Instead you should set the layerNeedsUpdate property to YES to cause this method to run at the end of the run loop, or you can call updateLayerIfNeeded() to force the layer to update immediately."
    
    Also
    
    "Instead of overriding this method, consider overidding the render() method instead, which is called both when creating and updating a layer. If you do not want your render() method called when updating a layer, then you should override this method instead."
  
  
  layerNeedsUpdate
    lets the system know layer is dirty; causes updateLayerIfNeeded to be called at end of runloop
    
  updateLayerIfNeeded()
    Updates the layer by calling updateLayer, but only if the view is visible onscreen and if layerNeedsUpdate is 
    set to YES. (usually you won't call this; you just schedule it to be called at end of runloop by setting
    layerNeedsUpdate. You shouldn't override it.)
    
    (if the view is *not* visible and you want it to update anyway, set the 'force' argument the YES)
    
  didCreateLayer(), willDestroyLayer() : let you set up and tear down, e.g., events on DOM elements in layer
  

  
  updateLayerLocation
  layerLocationNeedsUpdate (usually set by parentViewDidChange() ?)
  updateLayerLocation   (moves layer to new dom location; seems to use dom manipulation)
  updateLayerLocationIfNeeded  (checks layerLocationNeedsUpdate first)
  
  
  
  parentViewDidResize
    may be called when parent view resizes.
    calls this.viewDidResize() ONLY IF this view is not 'fixed', i.e., has top, left, *width*, and *height* defined
    
  beginLiveResize:
    calls this.willBeginLiveResize() (which your views can implement/override to get notification...)
    and then calls beginLiveResize() on child views
    
  endLiveResize:
    calls endLiveResize() on child views
    then calls this.didEndLiveResize if it has been implemented
    
  (note how willBegiveLiveResize() and didEndLiveResize() are paired)
  
---


SC.RenderContext.element() returns the DOM node for the RenderContext
  1. if the RenderContext already is associated with a DOM node (e.g., if you passed its constructor a node) it returns that node
  2. if the RenderContext does not already have an associated DOM node (e.g., if you passed a tag name string to its constructor) it creates a node.
  
    You won't see much of createElement(); the SC.RenderContext *class* contains a 'factory' property that references a div node. (the factory DOM node is kept around, and only created (recreated?) if the 'factory' property is undefined when element() is called)
    
  SC.RenderContext.element() creates a node by setting the whole string of the render context (i.e., including the outermost tag of the layer!) to be the innerHTML of the 'factory' node, then cloning that node and returning a reference to the clone.
  
  when 
    
    
    
  *** 'frame' property of view represents the bounding rect for the view, relative to the top left corner of the parent view
    
    
  ALSO, from frozencanuck:
  
  * Views are rendered lazily once they are added to the screen
  automatically as part of the runloop. You should never call render()
  yourself. If you need to make a view re-render, you can call
  view.displayDidChange(). This will schedule the view to re-render (via Charles Jolley)
  
  I say:
  
  - default implementation of displayDidChange just sets layerNeedsUpdate; I suppose that you should call
  displayDidChange() though, because views may have overriden displayDidChange in order to get a different kind of
  notification.)
  - view init just adds displayDidChange as an observer on all the displayProperties
  

* context objects and delayed html construction?

  see above
  

* responders and statecharts


   Punt. You can figure this out later.
   

* how to get a StackedView to stretch 'on command' (if not automatically, since it's hard to get change events from dom)

 see the above layout discussion AND take note of the following property:
 
 SC.View.childViewsNeedLayout [R/W]

  Set this property to YES whenever the view needs to layout its child views. 
  Normally this property is set automatically whenever the layout property for a child view changes.
  



---



from frozencanuck:

* Always use SC.none() to test for null/undefined values. For example, (“” == false) is true in JavaScript (via martoche)
* Don’t forget to call awake() to synchronise the bindings after you append() a pane (via martoche)
* Views are rendered lazily once they are added to the screen
automatically as part of the runloop. You should never call render()
yourself. If you need to make a view re-render, you can call
view.displayDidChange(). This will schedule the view to re-render (via Charles Jolley)
* Dynamic properties are pretty cool, they are done by implementing the unknownProperty method. (via martoche)




refactoring notes:

make DataSeriesView a CollectionView (not necessarily a ListView, but maybe) and set its exampleView to DataPointView

DataPointView can have isSelected, isEnabled properties to represent itself a
(then probably you can just bind 'selection' on DataSeriesView without having to do too much more)
