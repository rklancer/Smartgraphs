Plan, based on Priorities section below:

0. Focus on the instantaneous-speed activity, loaded into the app to eliminate the couchdb update cycle for now. (Done.)

Ideal is to gradually replace everything. Build the tools needed to make the new things work before removing the old things.

2. Make the expression-evaluator extensible and make it possible for certain expression terms to 'autoregister' as observers of the relevant property. (Done.)

3. Make response branches use expressions instead of inspectors. (Done.)

4. Make submissibility use an expression instead of an inspector (this is a good first test of "live" expressions) (Done.)


--


Next: 

* make 'setVariable' and 'substitutedExpressions' use new expressions instead of inspectors. (Done.)
* make the slope tool logic (and prompts?) work with negative slopes. (Done.)

* fix up evaluator:
  (0) .nArgs, .minArgs, .maxArgs; Smargraphs.evaluator.defs( function () { def(...) ..} instead of Smartgraphs.evaluator.def()
  (1) recognize distinction between variables and names
  (2) builtin support for values that carry units around with them
  (3) rationalize and organize the operators used so far (some expect annotation names an dereference the 'point' property; others expect variable names, others expect literal values...)
  (4) elegance question: should we evaluate a name to get a lambda instead of special-casing operator recognition? How easy would it be to make reduce, apply, etc work and should such a thing be done in this case?


Then (this restates steps 5-8 below):

 * add 'context' to activityPage, convert activityObjectsController to be global context
 * replace setVariable with 'name: expression' pairs in the step definition (which define 'name' in the context). Or route these through setVariable...
 * Always process beforeText/afterText through handlebars templates, which are automatically provided with local and global context objects. Use this to replace 'substitutedExpressions' and 'processSubstitutions'.

 
 
 

5. Add a 'context' property to activityPage as SC.Record.attr(Object) property whose defaultValue is {}. When doing this story and the next story (about refactoring activityObjects into a global context), remember that we need to generate simple context objects usable by Handlebars templates so that authors can easily specify "the 'height' expression from the previous page" https://github.com/sproutcore/sproutcore/commit/21a6ab0a9364665af6411c55857d6f4c2789c616

6. activityObjectsController has to be refactored to be a global context of some sort; and there should be a single 'getFromContext' (possibly 'find'; current usage of 'find' seems mostly to be store & jquery related) method that gets from the page context first, and then from the global context (so there's shadowing of a sort)

7. Define name: expression pairs in the current context and 'shapshot' when done. Create a model objects called ExpressionDefinition that is linked to page, step (why? for analogy to AnnotationDefinition)

8. Incoporate templates into activity steps, using variables.

At this point, we should be able to complete the "authoring steps" story.

Now, onwards!

9. Switch to defining annotations inline using 'AnnotationDefinition' "child" records on a step

10. Make it so any annotation highlighting is a property of a step (i.e., is transient & not done via a command)

11. Finally eliminate Graph model

12. Cleanup from above



Priorities:
 
(0) Graph declarations should be 'stateless'. Each step declares what is and is not on the graph. (though *implementation* should look at deltas from step to step to avoid lots of svg/vml node creation and destruction) Probably get rid of Graph model? A graph is made 'just-in-time' from the stateful components (datasets, annotations, axes) It would be valuable to keep 'Axis' model around as authors may want to reuse certain axes at different places in the activity.

Principle: if user modifies axis limits, etc, ask if they want to change all axes or a subset and provide UI allowing them to rename some of the axes. Similarly, when a user changes the graphs/table layout and datasets (NOT annotations) AND the change doesn't refer to a dataset newly created in the step, ask if you want to change the layout for all steps on the page or just this step.

(0b) Expected behavior is, when creating a new step in the authoring interface, to copy the panes from the previous step (or from the 'page master'???)

(1) get rid of inspectors totally! They've led to some very awkward extensions -- make use of expressions

(2) Activity can declare a set of expressions or expressions can be used inline. Although we'll introduce indirection with expressions, so that mustache templates can be used, the UI can be very simple. click a point to open the expression builder and insert an template tag that references the expression at that place.

(3) modularize expression definitions so you can just append a function describing a new expression.

(4) Require annotations, datasets, and variables to be declared at the top of an activity. No dynamic *creation* of these during the activity -- though of course they are dynamically inited.

(5) As per 'graphs are stateless', each step declares what variables, annotations, and datasets it references/cares about (this set is not necessarily identical to the list of objects being shown during the step.) An init section describes via a each is inited (via a property: expression hash).... this way we can give warnings to authors who save activities with possibly-unitialized objects.

Question: What's the "continuation" path if user saves the session and wants to return to it? You have to jump to the relevant step, and certain annotations/datasets it may be showing might therefore be populated from saved session data instead of the tool or expression that "normally" would init the same dataset/annotation/variable

Presumably a session ends when in the ACTIVITY_STEP state ... should this be a guarantee? ... so session saving can be implemented by saving:
 * the activity, page, and step ids
 * hashes for the activity objects (variables, datasets, annotations)
 * hashes for any other changed models, like Axes if the student has modified any of them...
 * plus a version identifier?

and then reloading the activity step, redoing any init (which one would think shouldn't be a problem unless there are self-referential variables assignments...) and turning on any tools that are supposed to be turned on. An issue might arise here if we want to allow a user to save to the session, for example, sensor data they just input without submitting the step first. That said, it could be that the sensor tool recognizes when it starts up that data is already present, and go first to the state that turns on the "clear" button.


Notes & sketch of authoring tool
RPK 
Originally written 11/29/2010


Preparatory Refactoring Work:

This section describes some changes that I will make to already-existing Smartgraphs code in order to make the
development of authoring capabilities proceed as smoothly as possible. These won't be represented as explicit stories.
Rather, they will be undertaken piece-by-piece as part of implementing authoring stories.

In some cases, it is simply the case that these refactorings need to occur *eventually*, but because some authoring
code would need to be changed too when those refactorings are done, it will be wiser to do the refactoring before the
related authoring code is even written.

 * DONE: Transition from SC.Responders to the Statechart framework (formerly known as Ki). There are a number of
   places where we would like to use concurrent states, and/or represent nested states more cleanly, and the
   newly-added Statecharts framework will make this easier.

 * DONE: Remove "loading" states since we no longer use incremental loading.

 * DONE: Implement session using a nested store! (First, make sure that it's possible to save the session to the
   server using the changelog...) Note that this gets rid of the "find in session, then in activity" problem, AND it
   makes it easy to implement datasetList/annotationsList as queries backed by a list of names.
    
     * DONE rename sessionController -> activityObjectsController, keep createDataset, createAnnotation, add find
       methods
   
 * DONE: Implement a registry of all object (annotation/dataset) names used in the session. It is a runtime error to
   create an object with a pre-existing name. Use this registry to remove the requirement to specify the type of
   annotation from any smartgraph commands that don't specifically need it.

 * DONE: Make an inventory of commands and annotations. Remove code that depends on having an object open in a
   particular graph just in order to find that object.

--

  (test & document activityObjectsController)

 * Move table and graph state out of the controllers and into the related models. When annotations are added to a
   graph, they stay there until removed. Having the state in the controllers is something of an architectural mistake,
   and we should address this concern before implementing any new authoring capabilities on top of this.

 * Make datasetList, annotationList into queries that lazily find all the datasets/annotations with the specified
   names. Add datasetNames, annotationNames lists, rename datasetList -> datasets, annotationsList -> annotations;
   modify initialDatasets property; bump version #

 * Think about how tables and graphs *should* be linked -- what is the most *natural* way to specify that an
   annotation should be displayed on a table and a graph? What is the best way to tell the sensor mode to display in
   the graph as well as the table?

 * ? - Clean up Table model so that it parallels Graph. In the authoring interface, tables will have names, just like 
   graphs do, so make this true in the Smartgraphs runtime as well.

 * Smartgraphs.registerCommand() -- remove commands implementation from states?
 
 * Create a superstate of ACTIVITY_STEP and ACTIVITY_STEP_SUMITTED to represent actions available both presumbission
   and postsubmission, and to distinguish these from actions that are available when the activity is open generally.
   Note that these substates can now be labeled "notSubmitted" and "submitted", since they 'nest' inside ACTIVITY_STEP
   in a more natural way once we use the statechart framework.

 * canGotoNextPage and submissibility should be represented with STATEs!
   
 * Move Activity, ActivityPage, ActivityStep state *out* of controllers and into respective models
 
   Putting activity state in controllers was an understandable architectural mistake, and we should correct it before
   we build authoring capabilities on top of this mistaken design. As a side effect, it will be much easier to 
   *visit* an previously finished activity step or page. Although we will demo this capability to verify that state
   has indeed been moved out of the controllers, we won't yet create UI for visiting old activity pages. However, when
   we do create a story for visiting past activity, it will be easier to code it as a result of this work.)

 * Datasets should have a units model for the columns; refactor Axes to reference these. This is important for
   cleaning up the Table model (see the next bullet point.)
  
 * Graph model has to be able to "wait" for an annotation or dataset a given name to be created, just like table does.
   Part of this functionality may be provided by Session/sessionController. NOTE: the datasetList and annotationList
   should become RecordArrays backed by a query. When annotation records matching the specified criteria come into
   existence, they should be automatically added to the list.
   


 
 * clarify/organize the processing model of ActivitySteps a little better -- what about shouldAutoAdvance? What if
   there's no explicit Submissibility inspector defined in the step, yet the step is supposed to wait for submission?
   (Right now this logs a complaint to the console.)
      
 * Update existing activities with the new data format implied by these changes!
 
 * For later: The 2 "panes" on the right should be full fledged SC.Panes so they can have state, like FreehandInput.
   Note that it may be better to remove the FreehandInputController and put its logic into the FreehandInput *state*
  
 * For later: also combine SENSOR states and sensorController, although unlike FREEHAND_INPUT, SENSOR should probably 
   remain a global state.
 
 * A note for later: the ResponseTemplate model is a hack. There should be a Response object that gets saved with the 
   ActivityStep.
   
 * For later: consistent error handling if the activity is poorly specified. 

 * NO: Clean up the distinction between "example" (or canned) graphs, datasets, and annotations by creating
   SessionGraph, SessionDataset, and SessionAnnotation models that extend a common mixin that Graph, Dataset, and
   Annotation extend. Clean up usage of Session and SessionController by requiring everywhere that and clean up
   Session/SessionController handling. Meaning: sessionController should be responsible for finding a
   graph/table/dataset/annotation from the definition and duplicating it to the session if it hasn't been. The
   Session* models should inherit from a mixin shared by the base models (which are just called "Graph", "Dataset",
   etc.)

Notes toward implementation of the authoring side of Smartgraphs:

  Good time to start Lebowski tests!

  * We'll create an ActivityDataSource and a SessionDataSource. The ActivityDataSource knows how to serialize and 
    unserialize an Activity. The ActivityDataSource or an associated object should use the knowledge of what records
    constitute a given Activity to maintain an "Activity status" flag indicating whether the activity is saved or
    not. Committing the Activity record moves us into a "SAVING" state which implements no UI actions. (Use history 
    state support to return to where we were when finished.)
    
  * Add to the Activity data model a registry of the graph, dataset, annotation *names* in the dataset, with links
    to the related objects. (Perhaps this can be a transient property?) This will be used to allow the user to
    select a dataset (etc) from a dropdown, and to check that a name for a dataset doesn't duplicate other names used
    in the activity. Concurrent states can keep track of the fact that you need to finish specifying the name of a
    dataset on a graph, while not rigidly requiring you to enter it before moving on.
    
  * Implement a special controller class that keeps track of when fields have been edited. (Views bound to the
    controller can issue action when focus changes in order to let controller(s) know editing is completed.) The 
    controller issues "editField" actions with (model, fieldname, oldvalue, newvalue). These get saved in an 
    UndoManager (as do all other actions that affect the activity content, like creation of datasets, etc.)

  * Some states and actions:
  
    READY
      * create new activity (a toolbar option)
      
    ACTIVITY
      (note the transition from READY to ACTIVITY should enable the 'edit activity' control)
      * edit activity
      
    EDITING_ACTIVITY and substates:
    
      * action: move page!
      * action: editField on activity, page name, step name
      * move page
      * move step (I think we'll let users decide whether steps belong where they get put)
      * delete page
      * delete step
      
      state: activity page opened, but contains no steps
        * editField (see above about the edit class)
        * setPaneConfig (implicitly creates step first!)
        * createStep (uses a default pane config, etc. However, there might not be any UI just for creating a step?)
        * next page
        * prev page
        * editField (see above regarding undo manager)
      
      state: activity page opened to step x
        * createStep
        * setPaneConfig (possibly modifying pane config)
        * insertGraph (moves to a concurrent state that either waits for the user to specify a new graph name or pick
          a predefined one from the dropdown)
        * insertTable (similar to insertGraph)
      
      state: Graph open (substate on a pane -- the 2 right side panes should be SC.Panes so they can have state.) 
    
        * change axis label
        * add dataset
        * remove dataset
        * add annotation
        * remove annotation
        * click annotation (edit info about the annotation?)
        * click dataset (edit info about the dataset?)
        * insert tool (goes to "tool selection" state)

      state: Tool Selection
        (this opens up a pane which the user can specify what tool gets turned on in the graph in the step, if any)
    
      state: Step Navigation
        (i.e., the "submit" button was clicked. Opens up a pane to ask what the student's "action" was).
    
      a concurrent state: document is saved/not saved (serializer component/datasource observes status of models it cares 
      about to update this state)
    
      a mutually exclusive state: document is in the process of being saved. No UI actions during this time!
  
  * app window controller opens EditingView which in turn has its own EditingViewController a la ActivityViewController
  
  * Make Tool an explicit model, and make ActivityStep understand it (i.e., rather than using a command to turn on a 
    particular tool, create an explicit config for tools)
    
  * create & test serializer/unserializer in ActivityDataSource. Make it observe the models it serializes and 
    unserializes, so that it knows whether the activity is "saved" and provides a single place to trigger saving the 
    activity to couchdb.
  
  * we'll need annotations to be more descriptive about themselves, but I have no general model for this yet!
  
  * need metadata about tools and commands. At the very least, there should be pre and post conditions regarding the
    annotation and dataset models which are available at any given point. (i.e., this command requires annotation named
    x to exist before running...)
    
  * Control flow analysis of activities to verify whether annotations and datasets exist when needed. How to handle
    this cleanly? You don't necessarily want to prevent authors from taking actions which *temporarily* create an
    invalid activity -- that can be very awkward -- but you want to make sure they fix the problem eventually.
